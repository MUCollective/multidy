---
title: "Multiverse Syntax"
output: html_document
---

## Introduction

In this document, we outline some initial avenues for creating the syntax for a multiverse analysis. The goal is to identify a high-level data structure that can be used consistently throughout the analysis and can be manipulated in ways similar to a data.frame or tibble.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(knitr)
library(rlang)
library(tidyverse)
library(magrittr)
#library(multidy)
#library(modelr)
#library(rlang)
```

## The data
The first step is to read the raw data from the file and store it as a tibble. We will be following the *_tidy data_* format here. The data is stored in two text files, and we can use `readr` to read the files into R. In this example, we will use the data collected by *Durante et al.*, which investigated the effect of fertility on religiosity and political attitudes. We will focus on their second study (which we store in `data.raw.study2`).

```{r data}
data.raw.study2 <- read_delim("data/durante_etal_2013_study2.txt", delim = "\t",
    col_types = cols(
        DateTesting = col_date(format = "%m/%d/%y"),
        StartDateofLastPeriod =col_date(format = "%m/%d/%y"),
        StartDateofPeriodBeforeLast = col_date(format = "%m/%d/%y"),
        StartDateNext = col_date(format = "%m/%d/%y")
  )) %>%
  mutate(
    Abortion = abs(7 - Abortion) + 1,
    StemCell = abs(7 - StemCell) + 1,
    Marijuana = abs(7 - Marijuana) + 1,
    RichTax = abs(7 - RichTax) + 1,
    StLiving = abs(7 - StLiving) + 1,
    Profit = abs(7 - Profit) + 1,
    FiscConsComp = FreeMarket + PrivSocialSec + RichTax + StLiving + Profit,
    SocConsComp = Marriage + RestrictAbortion + Abortion + StemCell + Marijuana
  ) %>%
  mutate(ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast )
```

The data look like this:

```{r}
data.raw.study2 %>%
  head(10)
```

The original paper looked at the relationship between fertility, relationship status, and religiousity. But there are many reasonable ways to have defined each of these three variables from this dataset, so it is a good candidate for multiverse analysis.

## A single data set analysis: one possible analysis among many

The data collected needs to be processed before it can be modeled. Preparing the data set for analysis can involve several steps and decisions regarding how to encode the different raw values. The following is one example of data processing that can be performed for this study. 

```{r single_analysis, eval = FALSE}
one_universe = data.raw.study2 %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
  mutate( NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength ) %>%
  mutate(
    CycleDay = 28 - (NextMenstrualOnset - DateTesting),
    CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
  ) %>%
  mutate(
    Relationship = factor(ifelse(Relationship==1 | Relationship==2, "Single", "Relationship"))
  ) %>%
  filter( ComputedCycleLength > 25 & ComputedCycleLength < 35) %>%
  filter( Sure1 > 6 | Sure2 > 6 ) %>%
  mutate( Fertility = factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ) )
```

The transformed data for this one universe looks like this:

```{r}
one_universe %>%
  head(10)
```

```{r}
one_universe %>%
  ggplot(aes(x = Relationship, y = Rel1 + Rel2 + Rel3, color = Fertility)) +
  stat_summary(position = position_dodge(width = .1))
```

However, there also exists other valid processing options: instead of calculating `NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength`, it can also be calculated as `StartDateofLastPeriod + ReportedCycleLength`. Such alternate processing options can exist for several decisions that a researcher makes in the data processing, analysis and presentation stages. This can thus result in a *multiverse of analysis*, with the one described above representing a single *universe*. 

Below, we describe how our package allows you to conduct a multiverse analysis with ease.

## Defining the multiverse

`multidy` provides flexible functions which can be used to perform a multiverse analysis.

The first step is to define a *new multiverse*. We will use the multiverse object to create a set of universes, each representing a different way of analysing our data.



### 1. Define the concepts at play (maybe as you introduce them)
### 2. Split up the list of things in M to introduce them in context.
A `multiverse` object consists of the following attributes: 
1. `parameters`, which is a list of parameters
2. `conditions`, which is a list of conditions
3. `multiverse_tbl`, which is a tibble consisting of all possible combination of values for the multiverse
4. `current_parameter_assignment`, which is a list of values that each parameter defined in the multiverse can take. This should be the default analysis.
5. `code`, which is the code that the user passes to the multiverse to conduct a multiverse analysis. However, we do not execute this code and it is stored unevaluated. The user can interactively edit and rewrte this code, and can execute it for the current analysis or the entire multiverse using dedicated functions.
### 



```{r}
M <- multiverse()
```

The next step is to define our possible analyses inside the multiverse. The `multidy` package includes functions that aim to make it easy to write multiverse analyses in as close a way to a single universe analysis as possible (as seen in the single analysis shown above). 


Consider these first few lines from the transformation code in the single analysis above:

```{r eval=FALSE}
df <- data.raw.study2  %>%
  mutate(ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast) %>%
  mutate(NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength)
```

But `NextMenstrualOnset` could be calculated in at least two other reasonable ways:

* `NextMenstrualOnset = StartDateofLastPeriod + ReportedCycleLength`
* `NextMenstrualOnset = StartDateNext`

To create a multiverse that includes these three possible processing options, we can use the `branch()` function. The `branch()` function defines a *parameter* (here `menstrual_calculation`) and the different options that the parameter can take (here, `"mc_option1"`, `"mc_option2"`, `"mc_option3"`). Each option corresponds to a different chunk of code that would be executed in a different universe.

```{r, eval = FALSE}
inside(M, {
  df <- data.raw.study2  %>%
    mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
    mutate(NextMenstrualOnset = branch(menstrual_calculation, 
      "mc_option1" ~ StartDateofLastPeriod + ComputedCycleLength,
      "mc_option2" ~ StartDateofLastPeriod + ReportedCycleLength,
      "mc_option3" ~ StartDateNext)
    )
}
```

At this point, no code has been executed.

### 1. show what the parameter list looks like 
### 2. show that the code for each universe can be generated




To enable a multiverse analysis, this diverges from the single universe analysis in two ways:

1. the `branch` call which will contain the parameter and all the different values the parameter can take. The `branch` call takes in at least 3 arguments:
  a. the first argument is the name of the parameter. This is required.
  b. the subsequent arguments are the different options (or values) that each parameter can take which is passed in the form of <option_name> ~ <option_calculation>. Since this is a branch call, there should be two or more options.
2. the `inside` function or the `%is%` function which will be used to define variables into the multiverse.

We illustrate this in the subsequent code chunk. Here, we use the `inside` function and the different processing options are defined within the multiverse using the `branch` declaration. Within each branch, the user has defined a *parameter* and the different values that the parameter can take. For eg., the parameter *mentrual_calculation* can be calculated using 3 options: `StartDateofLastPeriod + ComputedCycleLength`; `StartDateofLastPeriod + ReportedCycleLength`; or `StartDateNext`.

```{r eval = FALSE}
M <- multiverse()

inside(M, {
  df <- data.raw.study2  %>%
    mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
    mutate(NextMenstrualOnset = branch(menstrual_calculation, 
      "mc_option1" ~ StartDateofLastPeriod + ComputedCycleLength,
      "mc_option2" ~ StartDateofLastPeriod + ReportedCycleLength,
      "mc_option3" ~ StartDateNext)
    ) %>%
    mutate(Relationship = branch( relationship_status, 
      "rs_option1" ~ factor(ifelse(Relationship==1 | Relationship==2, 'Single', 'Relationship')),
      "rs_option2" ~ factor(ifelse(Relationship==1, 'Single', 'Relationship')),
      "rs_option3" ~ factor(ifelse(Relationship==1, 'Single', ifelse(Relationship==3 | Relationship==4, 'Relationship', NA))) )
    ) %>%
    mutate(
      CycleDay = 28 - (NextMenstrualOnset - DateTesting),
      CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
    ) %>%
    filter( branch(cycle_length, 
      "cl_option1" ~ TRUE,
      "cl_option2" ~ ComputedCycleLength > 25 & ComputedCycleLength < 35,
      "cl_option3" ~ ReportedCycleLength > 25 & ReportedCycleLength < 35
    )) %>%
    filter( branch(certainty,
        "cer_option1" ~ TRUE,
        "cer_option2" ~ Sure1 > 6 | Sure2 > 6
    )) %>%
    mutate( Fertility = branch( fertile,
        "fer_option1" ~ factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ),
        "fer_option2" ~ factor( ifelse(CycleDay >= 6 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 27, "low", "medium")) ),
        "fer_option3" ~ factor( ifelse(CycleDay >= 9 & CycleDay <= 17, "high", ifelse(CycleDay >= 18 & CycleDay <= 25, "low", "medium")) ),
        "fer_option4" ~ factor( ifelse(CycleDay >= 8 & CycleDay <= 17, "high", "low") )
    ))
})
```

Alternatively, we can use the `%is%` operator to define variables within the multiverse. The syntax here is `<multiverse_object>$<variable_name> %is% <expression>`.

```{r}
M <- multiverse()

M$df <- ~ data.raw.study2  %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
    mutate(NextMenstrualOnset = branch(mentrual_calculation, 
      "mc_option1" ~ StartDateofLastPeriod + ComputedCycleLength,
      "mc_option2" ~ StartDateofLastPeriod + ReportedCycleLength,
      "mc_option3" ~ StartDateNext)
    ) %>%
    mutate(Relationship = branch( relationship_status, 
      "rs_option1" ~ factor(ifelse(Relationship==1 | Relationship==2, 'Single', 'Relationship')),
      "rs_option2" ~ factor(ifelse(Relationship==1, 'Single', 'Relationship')),
      "rs_option3" ~ factor(ifelse(Relationship==1, 'Single', ifelse(Relationship==3 | Relationship==4, 'Relationship', NA))) )
    ) %>%
    mutate(
      CycleDay = 28 - (NextMenstrualOnset - DateTesting),
      CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
    ) %>%
    filter( branch(cycle_length, 
      "cl_option1" ~ TRUE,
      "cl_option2" ~ ComputedCycleLength > 25 & ComputedCycleLength < 35,
      "cl_option3" ~ ReportedCycleLength > 25 & ReportedCycleLength < 35
    )) %>%
    filter( branch(certainty,
        "cer_option1" ~ TRUE,
        "cer_option2" ~ Sure1 > 6 | Sure2 > 6
    )) %>%
    mutate( Fertility = branch( fertile,
        "fer_option1" ~ factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ),
        "fer_option2" ~ factor( ifelse(CycleDay >= 6 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 27, "low", "medium")) ),
        "fer_option3" ~ factor( ifelse(CycleDay >= 9 & CycleDay <= 17, "high", ifelse(CycleDay >= 18 & CycleDay <= 25, "low", "medium")) ),
        "fer_option4" ~ factor( ifelse(CycleDay >= 8 & CycleDay <= 17, "high", "low") )
    ))
```

## Parsing the multiverse

After defining the multiverse, we will need to go through the declaration and parse it to identify the parameters, and the values each parameter can take. The permutations of these values will result in the multiverse of analysis. Parsing will also allow us to convert it into functioning R syntax. 

We parse the multiverse in two steps. The first step is creating the `multiverse table` which contains all the combinations of the different values each parameter can take. The next step is extracting the syntax tree for a single analysis where the value of each parameter are variables corresponding to their values in each universe; we then use a list of parameter assignments --- for each branch, a set of values that each parameter takes which we use to output the code without branches.

The `parse_multiverse` function takes care of the first step.

```{r}
parse_multiverse(M)
```


## Running a single analysis from the multiverse

A single analysis corresponds to a particular set of values for each parameter that has been defined in the multiverse. If this set of values is passed as a list, the `get_universe` function returns an executable call for that particular analysis. This could then be inspected and evaluated using the `evaluate_universe` function to get the result.

```{r}
param.assgn <- list(
  mentrual_calculation = "mc_option1",
  relationship_status = "rs_option3",
  cycle_length = "cl_option2",
  certainty = "cer_option1",
  fertile = "fer_option4"
)

get_universe(M, param.assgn) %>%
  rlang::eval_tidy()
```

