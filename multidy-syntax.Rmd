---
title: "Multiverse Syntax"
output: html_document
---

## Introduction

In this document, we outline some initial avenues for creating the syntax for a multiverse analysis. The goal is to identify a high-level data structure that can be used consistently throughout the analysis and can be manipulated in ways similar to a data.frame or tibble.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(knitr)
library(rlang)
library(tidyverse)
library(magrittr)
#library(multidy)
#library(modelr)
#library(rlang)
```

### The data
The first step is to read the raw data from the file and store it as a tibble. We will be following the *_tidy data_* format here. The data is stored in two text files, and we can use `readr` to read the files into R. In this example, we will use the data collected by *Durante et al.*, which investigated the effect of fertility on religiosity and political attitudes. We will focus on their second study (which we store in `data.raw.study2`).

```{r data}
data.raw.study1 <- read_delim("data/durante_etal_2013_study1.txt", delim = "\t",
    col_types = cols(
        DateTesting = col_date(format = "%m/%d/%y"),
        StartDateofLastPeriod =col_date(format = "%m/%d/%y"),
        StartDateofPeriodBeforeLast = col_date(format = "%m/%d/%y")
))

data.raw.study2 <- read_delim("data/durante_etal_2013_study2.txt", delim = "\t",
    col_types = cols(
        DateTesting = col_date(format = "%m/%d/%y"),
        StartDateofLastPeriod =col_date(format = "%m/%d/%y"),
        StartDateofPeriodBeforeLast = col_date(format = "%m/%d/%y"),
        StartDateNext = col_date(format = "%m/%d/%y")
))

data.raw.study2 <- data.raw.study2 %>%
  mutate(
    Abortion = abs(7 - Abortion) + 1,
    StemCell = abs(7 - StemCell) + 1,
    Marijuana = abs(7 - Marijuana) + 1,
    RichTax = abs(7 - RichTax) + 1,
    StLiving = abs(7 - StLiving) + 1,
    Profit = abs(7 - Profit) + 1,
    FiscConsComp = FreeMarket + PrivSocialSec + RichTax + StLiving + Profit,
    SocConsComp = Marriage + RestrictAbortion + Abortion + StemCell + Marijuana
  ) %>%
  mutate(ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast )
```

### A single data set analysis: one possible analysis among many

The data collected needs to be processed before it can be modeled. Preparing the data set for analysis can involve several steps and decisions regarding how to encode the different raw values. The following is one example of data processing that can be performed for this study. 

```{r single_analysis, eval = FALSE}
data.raw.study2 %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
  mutate( NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength ) %>%
  mutate(
    CycleDay = 28 - (NextMenstrualOnset - DateTesting),
    CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
  ) %>%
  mutate(
    Relationship = factor(ifelse(Relationship==1 | Relationship==2, "Single", "Relationship"))
  ) %>%
  filter( ComputedCycleLength > 25 & ComputedCycleLength < 35) %>%
  filter( Sure1 > 6 | Sure2 > 6 ) %>%
  mutate( Fertility = factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ) ) %>%
  head()
```


However, there also exists other valid processing options: instead of calculating `NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength`, it can also be calculated as `StartDateofLastPeriod + ReportedCycleLength`. Such alternate processing options can exist for several decisions that a researcher makes in the data processing, analysis and presentation stages. This can thus result in a *multiverse of analysis*, with the one described above representing a single *universe*. 

Below, we describe how our package allows you to conduct a multiverse analysis with ease.

### Defining the multiverse

`multidy` provides flexible functions which can be used to perform a multiverse analysis.

The first step is to define a *new multiverse*. Here, a multiverse is an S3 object which will contain all the variables within a single scope. A `multiverse` object consists of the following attributes: 
1. `parameters`, which is a list of parameters
2. `conditions`, which is a list of conditions
3. `multiverse_tbl`, which is a tibble consisting of all possible combination of values for the multiverse
4. `current parameter assignment`, which is a list of values that each parameter defined in the multiverse can take. This should be the default analysis.
5. `code`, which is the code that the user passes to the multiverse to conduct a multiverse analysis. However, we do not execute this code and it is stored unevaluated. The user can interactively edit and rewrte this code, and can execute it for the current analysis or the entire multiverse using dedicated functions.

```{r}
M <- multiverse()
```

The next step is to define our possible analyses inside the multiverse. We define functions which allows the syntax for this step to closely follow the tidyverse syntax (as seen in the `single_analysis` code chunk above). To enable a multiverse analysis, this diverges from the single universe analysis in two ways:
1. the `branch` call which will contain the parameter and all the different values the parameter can take. The `branch` call takes in at least 3 arguments:
  a. the first argument is the name of the parameter. This is required.
  b. the subsequent arguments are the different options (or values) that each parameter can take which is passed in the form of <option_name> ~ <option_calculation>. Since this is a branch call, there should be two or more options.
2. the `inside` function or the `%is%` function which will be used to define variables into the multiverse.

We illustrate this in the subsequent code chunk. Here, we use the `inside` function and the different processing options are defined within the multiverse using the `branch` declaration. Within each branch, the user has defined a *parameter* and the different values that the parameter can take. For eg., the parameter *mentrual_calculation* can be calculated using 3 options: `StartDateofLastPeriod + ComputedCycleLength`; `StartDateofLastPeriod + ReportedCycleLength`; or `StartDateNext`.

```{r eval = FALSE}
M <- multiverse()

inside(M, {
  df <- data.raw.study2  %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
    mutate(NextMenstrualOnset = branch(mentrual_calculation, 
      "mc_option1" ~ StartDateofLastPeriod + ComputedCycleLength,
      "mc_option2" ~ StartDateofLastPeriod + ReportedCycleLength,
      "mc_option3" ~ StartDateNext)
    ) %>%
    mutate(Relationship = branch( relationship_status, 
      "rs_option1" ~ factor(ifelse(Relationship==1 | Relationship==2, 'Single', 'Relationship')),
      "rs_option2" ~ factor(ifelse(Relationship==1, 'Single', 'Relationship')),
      "rs_option3" ~ factor(ifelse(Relationship==1, 'Single', ifelse(Relationship==3 | Relationship==4, 'Relationship', NA))) )
    ) %>%
    mutate(
      CycleDay = 28 - (NextMenstrualOnset - DateTesting),
      CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
    ) %>%
    filter( branch(cycle_length, 
      "cl_option1" ~ TRUE,
      "cl_option2" ~ ComputedCycleLength > 25 & ComputedCycleLength < 35,
      "cl_option3" ~ ReportedCycleLength > 25 & ReportedCycleLength < 35
    )) %>%
    filter( branch(certainty,
        "cer_option1" ~ TRUE,
        "cer_option2" ~ Sure1 > 6 | Sure2 > 6
    )) %>%
    mutate( Fertility = branch( fertile,
        "fer_option1" ~ factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ),
        "fer_option2" ~ factor( ifelse(CycleDay >= 6 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 27, "low", "medium")) ),
        "fer_option3" ~ factor( ifelse(CycleDay >= 9 & CycleDay <= 17, "high", ifelse(CycleDay >= 18 & CycleDay <= 25, "low", "medium")) ),
        "fer_option4" ~ factor( ifelse(CycleDay >= 8 & CycleDay <= 17, "high", "low") )
    ))
})
```

Alternatively, we can use the `%is%` operator to define variables within the multiverse. The syntax here is `<multiverse_object>$<variable_name> %is% <expression>`.

```{r}
M <- multiverse()

M$df %is% {data.raw.study2  %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
    mutate(NextMenstrualOnset = branch(mentrual_calculation, 
      "mc_option1" ~ StartDateofLastPeriod + ComputedCycleLength,
      "mc_option2" ~ StartDateofLastPeriod + ReportedCycleLength,
      "mc_option3" ~ StartDateNext)
    ) %>%
    mutate(Relationship = branch( relationship_status, 
      "rs_option1" ~ factor(ifelse(Relationship==1 | Relationship==2, 'Single', 'Relationship')),
      "rs_option2" ~ factor(ifelse(Relationship==1, 'Single', 'Relationship')),
      "rs_option3" ~ factor(ifelse(Relationship==1, 'Single', ifelse(Relationship==3 | Relationship==4, 'Relationship', NA))) )
    ) %>%
    mutate(
      CycleDay = 28 - (NextMenstrualOnset - DateTesting),
      CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
    ) %>%
    filter( branch(cycle_length, 
      "cl_option1" ~ TRUE,
      "cl_option2" ~ ComputedCycleLength > 25 & ComputedCycleLength < 35,
      "cl_option3" ~ ReportedCycleLength > 25 & ReportedCycleLength < 35
    )) %>%
    filter( branch(certainty,
        "cer_option1" ~ TRUE,
        "cer_option2" ~ Sure1 > 6 | Sure2 > 6
    )) %>%
    mutate( Fertility = branch( fertile,
        "fer_option1" ~ factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ),
        "fer_option2" ~ factor( ifelse(CycleDay >= 6 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 27, "low", "medium")) ),
        "fer_option3" ~ factor( ifelse(CycleDay >= 9 & CycleDay <= 17, "high", ifelse(CycleDay >= 18 & CycleDay <= 25, "low", "medium")) ),
        "fer_option4" ~ factor( ifelse(CycleDay >= 8 & CycleDay <= 17, "high", "low") )
    ))
}
```

### Parsing the multiverse

After defining the multiverse, we will need to go through the declaration and parse it to identify the parameters, and the values each parameter can take. The permutations of these values will result in the multiverse of analysis. Parsing will also allow us to convert it into functioning R syntax. 

We parse the multiverse in two steps. The first step is creating the `multiverse table` which contains all the combinations of the different values each parameter can take. The next step is extracting the syntax tree for a single analysis where the value of each parameter are variables corresponding to their values in each universe; we then use a list of parameter assignments --- for each branch, a set of values that each parameter takes which we use to output the code without branches.

The `parse_multiverse` function takes care of the first step.

```{r}
parse_multiverse(M)
```


### Running a single analysis from the multiverse

A single analysis corresponds to a particular set of values for each parameter that has been defined in the multiverse. If this set of values is passed as a list, the `get_universe` function returns an executable call for that particular analysis. This could then be inspected and evaluated using the `evaluate_universe` function to get the result.

```{r}
param.assgn <- list(
  mentrual_calculation = "mc_option1",
  relationship_status = "rs_option3",
  cycle_length = "cl_option2",
  certainty = "cer_option1",
  fertile = "fer_option4"
)

get_universe(M, param.assgn) %>%
  rlang::eval_tidy()
```

