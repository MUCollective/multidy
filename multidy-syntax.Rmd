---
title: "Multiverse Syntax"
output: html_document
---

## Introduction

In this document, we outline some initial avenues for creating the syntax for a multiverse analysis. The goal is to identify a high-level data structure that can be used consistently throughout the analysis and can be manipulated in ways similar to a data.frame or tibble.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(knitr)
library(tidyverse)
library(magrittr)
library(multidy)
#library(modelr)
#library(rlang)
```

### The data
The first step is to read the raw data from the file and store it as a tibble. We will be following the *_tidy data_* format here.

```{r data}
data.raw.study1 <- read_delim("data/durante_etal_2013_study1.txt", delim = "\t",
    col_types = cols(
        DateTesting = col_date(format = "%m/%d/%y"),
        StartDateofLastPeriod =col_date(format = "%m/%d/%y"),
        StartDateofPeriodBeforeLast = col_date(format = "%m/%d/%y")
))

data.raw.study2 <- read_delim("data/durante_etal_2013_study2.txt", delim = "\t",
    col_types = cols(
        DateTesting = col_date(format = "%m/%d/%y"),
        StartDateofLastPeriod =col_date(format = "%m/%d/%y"),
        StartDateofPeriodBeforeLast = col_date(format = "%m/%d/%y"),
        StartDateNext = col_date(format = "%m/%d/%y")
))

data.raw.study2 <- data.raw.study2 %>%
  mutate(
    Abortion = abs(7 - Abortion) + 1,
    StemCell = abs(7 - StemCell) + 1,
    Marijuana = abs(7 - Marijuana) + 1,
    RichTax = abs(7 - RichTax) + 1,
    StLiving = abs(7 - StLiving) + 1,
    Profit = abs(7 - Profit) + 1,
    FiscConsComp = FreeMarket + PrivSocialSec + RichTax + StLiving + Profit,
    SocConsComp = Marriage + RestrictAbortion + Abortion + StemCell + Marijuana
  ) %>%
  mutate(ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast )
```

### An analysis in a single universe

The following is one example of data processing that can be performed for this study. However, there exists other valid processing options: instead of calculating `NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength`, it can also be calculated as `StartDateofLastPeriod + ReportedCycleLength`.

Such alternate processing options can exist for several decisions that a researcher makes in the data processing, analysis and presentation stages. This can thus result in a *multiverse of analysis*, with the one described below representing a single *universe*. 

Our goal in this project is to extend the syntax that one might use for a single analysis to a multiverse analysis, without signficant added effort on the part of the analyst.

```{r eg_data_processing}
data.raw.study2 %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
  mutate( NextMenstrualOnset = StartDateofLastPeriod + ComputedCycleLength ) %>%
  mutate(
    CycleDay = 28 - (NextMenstrualOnset - DateTesting),
    CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
  ) %>%
  mutate(
    Relationship = factor(ifelse(Relationship==1 | Relationship==2, "Single", "Relationship"))
  ) %>%
  filter( ComputedCycleLength > 25 & ComputedCycleLength < 35) %>%
  filter( Sure1 > 6 | Sure2 > 6 ) %>%
  mutate( Fertility = factor( ifelse(CycleDay > 9 & CycleDay <= 17, "high", ifelse(CycleDay > 17 & CycleDay <= 25, "low", "medium")) ) )
```

### Defining the multiverse

In what follows, we provide flexible functions which can be used to perform a multiverse analysis.

```{r define_multiverse,  eval = FALSE}
new_multiverse <- function (data = data.frame()) {
  x <- env()
  attr(x, "code") <- NULL
  attr(x, "param_table") <- NULL
  attr(x, "current") <- NULL
  
  class(x) <- "multiverse_obj"
  x
}

is.multiverse <- function(x) {
  inherits(x, "multiverse_obj")
}

inside <- function (multiverse, x) {
  stopifnot(is.multiverse(multiverse))
  analysis.expr <- enexpr(x)
  
  if (is_null(attr(multiverse, "code"))) {
    attr(multiverse, "code") <- analysis.expr
  } else {
    attr(multiverse, "code") <- attr(multiverse, "code") %>% 
      inset2(., length(.) + 1, analysis.expr[[2]])
  }
}
```

The first step is to define a *new multiverse*. Here, a multiverse is an R environment which will contain all the variables within a single scope. We then define our possible analyses inside the multiverse, using the `inside` function. Different processing options can be defined within the multiverse using the `branch` declaration. Within each branch, the user defines a *parameter* and the different values that the parameter can take.

For example: we define a parameter *mentrual_calculation* which can be calculated using 3 options.
1. StartDateofLastPeriod + ComputedCycleLength
2. StartDateofLastPeriod + ReportedCycleLength
3. StartDateNext

For each parameter, value names and their corresponding calculation are declared within `branch`. 

In the following code chunk, we declare the multiverse data processing for our dataset.

*_ ISSUE: adding subsequent code inside the multiverse rewrites the previous._*

```{r eval = FALSE}
M <- multiverse()

inside(M, {
  df <- data.raw.study2  %>%
  mutate( ComputedCycleLength = StartDateofLastPeriod - StartDateofPeriodBeforeLast ) %>%
    mutate(NextMenstrualOnset = branch(mentrual_calculation, 
      "mc_option1" ~ StartDateofLastPeriod + ComputedCycleLength,
      "mc_option2" ~ StartDateofLastPeriod + ReportedCycleLength,
      "mc_option3" ~ StartDateNext)
    ) %>%
    mutate(Relationship = branch( relationship_status, 
      "rs_option1" ~ factor(ifelse(Relationship==1 | Relationship==2, 'Single', 'Relationship')),
      "rs_option2" ~ factor(ifelse(Relationship==1, 'Single', 'Relationship')),
      "rs_option3" ~ factor(ifelse(Relationship==1, 'Single', ifelse(Relationship==3 | Relationship==4, 'Relationship', NA))) )
    )
})

inside(M, {
   df <- df %>%
    mutate(
      CycleDay = 28 - (NextMenstrualOnset - DateTesting),
      CycleDay = ifelse(CycleDay > 1 & CycleDay < 28, CycleDay, ifelse(CycleDay < 1, 1, 28))
    ) %>%
    filter( branch(cycle_length, 
      "cl_option1" ~ TRUE,
      "cl_option2" ~ ComputedCycleLength > 25 & ComputedCycleLength < 35,
      "cl_option3" ~ ReportedCycleLength > 25 & ReportedCycleLength < 35
    )) %>%
    filter( branch(certainty,
        "cer_option1" ~ TRUE,
        "cer_option2" ~ Sure1 > 6 | Sure2 > 6
    )) %>%
    mutate( Fertility = branch( fertile,
        "fer_option1" ~ factor( ifelse(CycleDay >= 7 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 25, "low", "medium")) ),
        "fer_option2" ~ factor( ifelse(CycleDay >= 6 & CycleDay <= 14, "high", ifelse(CycleDay >= 17 & CycleDay <= 27, "low", "medium")) ),
        "fer_option3" ~ factor( ifelse(CycleDay >= 9 & CycleDay <= 17, "high", ifelse(CycleDay >= 18 & CycleDay <= 25, "low", "medium")) ),
        "fer_option4" ~ factor( ifelse(CycleDay >= 8 & CycleDay <= 17, "high", "low") )
    ))
})
```

### Parsing the multiverse

After defining the multiverse, we will need to go through the declaration and parse it into functioning R syntax. For a multiverse analysis, this involves two steps. The first is the table of all possible and reasonable combinations of analysis. The next step would be to extract the syntax tree and insert the relevant operations for each analysis corresponding to a single path in the multiverse.

```{r helper_functions,  eval = FALSE}
expr_type <- function(x) {
  if (rlang::is_syntactic_literal(x)) {
    "constant"
  } else if (is.symbol(x)) {
    "symbol"
  } else if (is.call(x)) {
    "call"
  } else if (is.pairlist(x)) {
    "pairlist"
  } else {
    typeof(x)
  }
}

switch_expr <- function(x, ...) {
  switch(expr_type(x),
    ...,
    stop("Don't know how to handle type ", typeof(x), call. = FALSE)
  )
}
```

The following functions recursively parses the abstract syntax tree, to identify the branches in data processing. It then creates the parameter table which contains the set of all possible and reasonable combinations of the values of each parameters that constitute the multiverse.

```{r eval = FALSE}
# takes as input an expression
# returns as output a paramater condition list whose structure
# resembles list(parameter = list(), condition = list())
get_parameter_conditions <- function(.expr) {
  switch_expr(.expr,
    # Base cases
    constant = , # falls through; the next element is evaluated
    symbol = list(parameters = list(), conditions = list()),

    # Recursive cases
    call = {
      child_parameter_conditions <- map(.expr, get_parameter_conditions) %>%
          reduce(combine_parameter_conditions)
      
      if (is_call(.expr, "branch")) {
        get_branch_parameter_conditions(.expr) %>%
          combine_parameter_conditions(child_parameter_conditions)
      } else {
        child_parameter_conditions
      }
    }
  )
}

# takes as input two lists list(parameter = list(), condition = list())
# returns as output a list(parameter = list(), condition = list()), 
# which is a concatenation of the two lists provided as input
combine_parameter_conditions <- function(l1, l2) {
  list(
    parameters = c(l1$parameters, l2$parameters),
    conditions = c(l1$conditions, l2$conditions)
  )
}

# takes as input a `branch` call which contains a parameter name 
# and parameter processing options. Parameter option names is optional
# returns as output a list(parameter = list(), condition = list())
get_branch_parameter_conditions <- function(.branch_call) {
  if (! is_symbol(.branch_call[[2]])) {
    stop("parameter names should be symbols")
  }
  parameter_name <- as.character(.branch_call[[2]])
  parameter_options <- map(.branch_call[-1:-2], ~ .x[[2]])
  
  parameter_options_list <- list(parameter_options)
  names(parameter_options_list) <- parameter_name
  
  list(parameters = parameter_options_list, conditions = list())
}

parse_multiverse <- function(M) {
  parameter_conditions_list <- get_parameter_conditions( attr(M, "code") )
  attr(M, "parameters") <- parameter_conditions_list
}
```


```{r}
parse_multiverse(M)
```

The second step is to extract the expression (R syntax) corresponding to a single analysis.
This requires a list of parameter assignments --- for each branch, a set of values that each parameter takes.
Given this, we output the code without branches.

```{r assemble_code,  eval = FALSE}
# takes as input: parameter assignment, and an expression (or code) which contains branches
# returns as output an expression (or code) without branches
get_parameter_code <- function(.expr, .assgn) {
  switch_expr(.expr,
    # Base cases
    constant = , # falls through; the next element is evaluated
    symbol = .expr,

    # Recursive cases
    call = {
      if (is_call(.expr, "branch")) {
        compute_branch(.expr, .assgn) %>%
          get_parameter_code(.assgn)
      } else {
        as.call(map(.expr, ~ get_parameter_code(.x, .assgn)))
      }
    }
  )
}

# takes as input:  parameter assignment, and the expression or code containing a branch
# returns as output an expression (or code) without the branch
compute_branch <- function(.expr, .assgn) {
  assigned_parameter_option_name <- .assgn[[.expr[[2]]]]
  parameter_values <- .expr[-1:-2]
  
  assigned_parameter_option_value <- map2(parameter_values, 
                                          assigned_parameter_option_name, function(.x, .y) .y %in% as.character(.x) ) %>% 
                                        flatten_lgl() %>%
                                        which(arr.ind = TRUE)
  
  parameter_values %>%
    extract2(assigned_parameter_option_value) %>%
    extract2(3)
}

# wrapper function for get_parameter_code
get_code <- function(M, .assgn) {
  get_parameter_code(attr(M, "code"), .assgn)
}
```


```{r}
param.assgn <- list(
  mentrual_calculation = "mc_option1",
  relationship_status = "rs_option3",
  cycle_length = "cl_option2",
  certainty = "cer_option1",
  fertile = "fer_option4"
)

get_code(M, param.assgn) %>%
  eval_tidy()
```

