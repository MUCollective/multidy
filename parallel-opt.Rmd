---
title: "Multiverse code block"
author: "Abhraneel Sarma"
output: 
  html_document:
    css: styles.css
---


```{r setup, include=FALSE}
library(knitr)
library(dplyr)
library(purrr)
library(future)
library(furrr)
library(parallel)

options(mc.cores = parallel::detectCores(logical = FALSE))
# options(future.supportsMulticore.unstable = "quiet")
```

## Parallelisation

```{r, data}
data("vis_correlation")
df <- vis_correlation
```

```{r}
n = 20

M = multiverse()

inside(M, {
  set.seed(branch(seed, .options = 1:n))
  
  data.i = vis_correlation %>%
    group_by(rbase, sign, vis, approach) %>%
    summarise( jnd = list(jnd), .groups = "drop" ) %>%
    mutate( 
      sample_size = map_dbl(jnd, length ),
      bootstrap_samples = map(jnd, ~ sample( .x, size = sample_size, replace = TRUE))
    )
})
```

```{r}
test_mapply <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = lapply(seq_len(length(.code_list)), function(x) new.env(parent = caller_env()) )
  
  results <- mapply(execute_code_from_universe, .code_list, .env_list) # does not do cat
  
  results
}

test_mcmapply <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = lapply(seq_len(length(.code_list)), function(x) new.env(parent = caller_env()) )
  
  results <- mcmapply(execute_code_from_universe, .code_list, .env_list, mc.cores = 6) # does not do cat
  
  results
}

cl <- makeCluster(getOption("mc.cores"))
test_clusterMap <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = lapply(seq_len(length(.code_list)), function(x) new.env(parent = caller_env()) )
  
  results <- clusterMap(cl, execute_code_from_universe, .code_list, .env_list) # does not do cat
  
  results
}


plan(multiprocess)
test_futuremap <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = lapply(seq_len(length(.code_list)), function(x) new.env(parent = caller_env()) )
  
  results <- future_map2(.code_list, .env_list, ~ execute_code_from_universe(.x, .y), .options = future_options(packages = "dplyr")) # does not do cat
  
  results
}

test_futuremap(M)
test_clusterMap(M)

microbenchmark::microbenchmark(test_mapply(M), test_mcmapply(M))
```

```{r}
execute_code_from_universe <- function(c, env) {
  e <- tryCatch( invisible( lapply(c, eval, envir = env) ), error = function(e) e )
  if (is(e, "error")) e$message else env
  # invisible( lapply(c, eval, envir = env) )
}

m_tbl = attr(M, "multiverse")[['multiverse_table']]
code_list = m_tbl[['.code']]
env_list = lapply(seq_len(length(code_list)), function(x) global_env()) #new.env(parent = caller_env()) )
```

```{r}
cl <- makeCluster(getOption("mc.cores"))
clusterEvalQ(cl, { 
  library(purrr)
  library(dplyr)
})

results <- clusterMap(cl, execute_code_from_universe, code_list, env_list)

results
```


```{r}
plan(multiprocess)
results <- future_map2(code_list, env_list, ~ execute_code_from_universe(.x, .y)) # does not do cat

results
```



```{r}
test_clusterMap <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = lapply(.code_list, function(x) new.env(parent = globalenv()))
  
  results <- clusterMap(cl, execute_code_from_universe, .code_list, .env_list) # does not do cat
  
  results
}

test_clusterMap(M)
```


```{r}
cl <- makeCluster(getOption("mc.cores"))
results <- clusterMap(cl, execute_code_from_universe, .code_list, .env_list)
```



```{r}
data("vis_correlation")

M = multiverse()

n = 100

inside(M, {
  set.seed(branch(seed, .options = 1:n))
  
  data.i = vis_correlation %>%
    group_by(rbase, sign, vis, approach) %>%
    summarise( jnd = list(jnd), .groups = "drop" ) %>%
    mutate( 
      sample_size = map_dbl(jnd, length ),
      bootstrap_samples = map(jnd, ~ sample( .x, size = sample_size, replace = TRUE))
    ) %>%
    select(-jnd) %>%
    tidyr::unnest( cols = c(bootstrap_samples)) %>%
    rename( jnd = bootstrap_samples )
})
```


```{r}
execute_code_from_universe <- function(.c, .env) {
  e <- tryCatch(invisible(lapply(.c, eval, envir = .env)), error = function(e) e)
  # if (is(e, "error")) cat(e)
  .env
}

test_mapply <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = m_tbl[['.results']]
  .universe = seq(1:nrow(m_tbl))
  
  res <- mapply(execute_code_from_universe, .code_list, .env_list)
}

test_mcmapply <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = m_tbl[['.results']]
  .universe = seq(1:nrow(m_tbl))
  
  res <- mcmapply(execute_code_from_universe, .code_list, .env_list, mc.cores = 6)
}

test_clustermap <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = m_tbl[['.results']]
  .universe = seq(1:nrow(m_tbl))
  
  res <- clusterMap(cl, execute_code_from_universe, .code_list, .env_list)
}

test_futuremap <- function(m) {
  m_tbl = attr(m, "multiverse")[['multiverse_table']]
  .code_list = m_tbl[['.code']]
  .env_list = m_tbl[['.results']]
  .universe = seq(1:nrow(m_tbl))
  
  res <- future_map2(.code_list, .env_list, execute_code_from_universe)
}

cl <- makeCluster(getOption("mc.cores"))
plan(multiprocess)

microbenchmark::microbenchmark(
  test_mapply(M),
  test_futuremap(M),
  test_clustermap(M),
  test_mcmapply(M)
)
```




